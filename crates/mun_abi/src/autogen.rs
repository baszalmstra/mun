//! Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`

/* automatically generated by rust-bindgen */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
use crate::{Privacy, StructMemoryKind, TypeGroup};

#[doc = " Represents a globally unique identifier (GUID)."]
#[doc = ""]
#[doc = " GUIDs are generated by taking the MD5 hash of a type's name."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Copy\" derive=\"Debug\" derive=\"Eq\" derive=\"PartialEq\" derive=\"Ord\" derive=\"PartialOrd\"></div>"]
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd)]
pub struct Guid {
    #[doc = " 16-byte MD5 hash"]
    pub b: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_Guid() {
    assert_eq!(
        ::std::mem::size_of::<Guid>(),
        16usize,
        concat!("Size of: ", stringify!(Guid))
    );
    assert_eq!(
        ::std::mem::align_of::<Guid>(),
        1usize,
        concat!("Alignment of ", stringify!(Guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Guid>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Guid), "::", stringify!(b))
    );
}
#[doc = " Represents the type declaration for a value type."]
#[doc = ""]
#[doc = " TODO: add support for structs, polymorphism, enumerations, type parameters, generic type definitions, and constructed generic types."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct TypeInfo {
    #[doc = " Type GUID"]
    pub guid: Guid,
    #[doc = " Type name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The exact size of the type in bits without any padding"]
    pub size_in_bits: u32,
    #[doc = " The alignment of the type"]
    pub alignment: u8,
    #[doc = " Type group"]
    pub group: TypeGroup,
}
#[test]
fn bindgen_test_layout_TypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<TypeInfo>(),
        32usize,
        concat!("Size of: ", stringify!(TypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<TypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(TypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).size_in_bits as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(size_in_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).alignment as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).group as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(group)
        )
    );
}
#[doc = " Represents a function signature."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionSignature {
    #[doc = " Function name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Argument types"]
    pub arg_types: *const *const TypeInfo,
    #[doc = " Optional return type"]
    pub return_type: *const TypeInfo,
    #[doc = " Number of argument types"]
    pub num_arg_types: u16,
    #[doc = " Function accessibility level"]
    pub privacy: Privacy,
}
#[test]
fn bindgen_test_layout_FunctionSignature() {
    assert_eq!(
        ::std::mem::size_of::<FunctionSignature>(),
        32usize,
        concat!("Size of: ", stringify!(FunctionSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionSignature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).arg_types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(arg_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).return_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).num_arg_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(num_arg_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).privacy as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(privacy)
        )
    );
}
#[doc = " Represents a function declaration."]
#[doc = ""]
#[doc = " `fn_ptr` can be used to call the declared function."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionInfo {
    #[doc = " Function signature"]
    pub signature: FunctionSignature,
    #[doc = " Function pointer"]
    pub fn_ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FunctionInfo() {
    assert_eq!(
        ::std::mem::size_of::<FunctionInfo>(),
        40usize,
        concat!("Size of: ", stringify!(FunctionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionInfo>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionInfo>())).fn_ptr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionInfo),
            "::",
            stringify!(fn_ptr)
        )
    );
}
#[doc = " Represents a struct declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct StructInfo {
    #[doc = " Struct fields' names"]
    pub field_names: *const *const ::std::os::raw::c_char,
    #[doc = " Struct fields' information"]
    pub field_types: *const *const TypeInfo,
    #[doc = " Struct fields' offsets"]
    pub field_offsets: *const u16,
    #[doc = " Number of fields"]
    pub num_fields: u16,
    #[doc = " Struct memory kind"]
    pub memory_kind: StructMemoryKind,
}
#[test]
fn bindgen_test_layout_StructInfo() {
    assert_eq!(
        ::std::mem::size_of::<StructInfo>(),
        32usize,
        concat!("Size of: ", stringify!(StructInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<StructInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(StructInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).field_names as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(field_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).field_types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(field_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).field_offsets as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(field_offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).num_fields as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(num_fields)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).memory_kind as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(memory_kind)
        )
    );
}
#[doc = " Represents an array declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct ArrayInfo {
    #[doc = " The type of the elements the array stores, e.g.: [T] -> an array that stores T's"]
    pub element_type: *const TypeInfo,
}
#[test]
fn bindgen_test_layout_ArrayInfo() {
    assert_eq!(
        ::std::mem::size_of::<ArrayInfo>(),
        8usize,
        concat!("Size of: ", stringify!(ArrayInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayInfo>())).element_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayInfo),
            "::",
            stringify!(element_type)
        )
    );
}
#[doc = " Represents a module declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct ModuleInfo {
    #[doc = " Module path"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Module functions"]
    pub functions: *const FunctionInfo,
    #[doc = " Number of module functions"]
    pub num_functions: u32,
    #[doc = " Module types"]
    pub types: *const *const TypeInfo,
    #[doc = " Number of module types"]
    pub num_types: u32,
}
#[test]
fn bindgen_test_layout_ModuleInfo() {
    assert_eq!(
        ::std::mem::size_of::<ModuleInfo>(),
        40usize,
        concat!("Size of: ", stringify!(ModuleInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ModuleInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).functions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).num_functions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(num_functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).num_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(num_types)
        )
    );
}
#[doc = " Represents a function dispatch table. This is used for runtime linking."]
#[doc = ""]
#[doc = " Function signatures and pointers are stored separately for cache efficiency."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct DispatchTable {
    #[doc = " Function signatures"]
    pub signatures: *const FunctionSignature,
    #[doc = " Function pointers"]
    pub fn_ptrs: *mut *const ::std::os::raw::c_void,
    #[doc = " Number of functions"]
    pub num_entries: u32,
}
#[test]
fn bindgen_test_layout_DispatchTable() {
    assert_eq!(
        ::std::mem::size_of::<DispatchTable>(),
        24usize,
        concat!("Size of: ", stringify!(DispatchTable))
    );
    assert_eq!(
        ::std::mem::align_of::<DispatchTable>(),
        8usize,
        concat!("Alignment of ", stringify!(DispatchTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).signatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(signatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).fn_ptrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(fn_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).num_entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(num_entries)
        )
    );
}
#[doc = " Represents an assembly declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct AssemblyInfo {
    #[doc = " Symbols of the top-level module"]
    pub symbols: ModuleInfo,
    #[doc = " Dispatch table"]
    pub dispatch_table: DispatchTable,
    #[doc = " Paths to assembly dependencies"]
    pub dependencies: *const *const ::std::os::raw::c_char,
    #[doc = " Number of dependencies"]
    pub num_dependencies: u32,
}
#[test]
fn bindgen_test_layout_AssemblyInfo() {
    assert_eq!(
        ::std::mem::size_of::<AssemblyInfo>(),
        80usize,
        concat!("Size of: ", stringify!(AssemblyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AssemblyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AssemblyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).symbols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(symbols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).dispatch_table as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(dispatch_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).dependencies as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(dependencies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).num_dependencies as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(num_dependencies)
        )
    );
}
